#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_shader_invocation_reorder : enable

layout(location = 0) rayPayloadEXT vec3 payload;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, std430) buffer ResultBuffer {
    uint hits;
};

layout(push_constant) uniform PushConstants {
    uint rayCount;
    float coherenceFactor;
    uint seed;
    uint enableSER;
} pc;

uint hash(uint seed) {
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

void main() {
    uint idx = gl_LaunchIDEXT.x;
    if (idx >= pc.rayCount) return;

    float gridWidth = sqrt(float(pc.rayCount));
    uint ix = idx % uint(gridWidth);
    uint iy = idx / uint(gridWidth);
    
    float fx = (float(ix) / gridWidth) * 200.0 - 100.0;
    float fy = (float(iy) / gridWidth) * 200.0 - 100.0;

    uint state = hash(idx + pc.seed);
    float jx = float(state % 100) / 100.0 * 0.5;
    state = hash(state);
    float jy = float(state % 100) / 100.0 * 0.5;
    
    vec3 origin = vec3(fx + jx, fy + jy, -10.0);
    vec3 dir = vec3(0.0, 0.0, 1.0);
    
    payload = vec3(0.0);
    
    // SER Reordering
    hitObjectEXT hObj;
    hitObjectTraceRayEXT(hObj, topLevelAS, gl_RayFlagsNoneEXT, 0xFF, 0, 0, 0, origin, 0.001, dir, 100.0, 0);
    reorderThreadEXT(hObj);
    hitObjectExecuteShaderEXT(hObj, 0);

    atomicAdd(hits, uint(payload.x * 100.0) + uint(payload.y * 10.0) + uint(payload.z));
}
