#version 460
#extension GL_EXT_ray_query : enable

layout(local_size_x = 32) in;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1) buffer Results {
    uint hits;
} results;

layout(push_constant) uniform PushConstants {
    uint rayCount;
    float coherenceFactor; // 0.0 to 1.0 (0 = completely random, 1 = completely coherent)
    uint seed;
} pc;

shared uint localHits;

// Simple LCG hash function for random number generation
uint hash(uint state) {
    state ^= state >> 16;
    state *= 0x85ebca6b;
    state ^= state >> 13;
    state *= 0xc2b2ae35;
    state ^= state >> 16;
    return state;
}

float rand(inout uint state) {
    return float(hash(state)) / 4294967296.0;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= pc.rayCount) return;

    if (gl_LocalInvocationID.x == 0) {
        localHits = 0;
    }
    barrier();

    // Initialize RNG state for this invocation
    uint rngState = idx + pc.seed;

    // We shoot from above the flat plane at Z=-10.0, looking downward.
    // Keep X and Y constrained within the bounds of the -100 to 100 quad.
    vec3 origin = vec3(
        (rand(rngState) * 180.0) - 90.0,
        (rand(rngState) * 180.0) - 90.0,
        -10.0
    );
    
    // Add micro-perturbations to the primary ray direction to defeat hardware implicit ray sorting
    vec3 direction = normalize(vec3(
        (rand(rngState) * 0.04) - 0.02,
        (rand(rngState) * 0.04) - 0.02,
        1.0
    ));

    float tMin = 0.001;
    float tMax = 20.0; // Floor is at Z=0, so distance is exactly 10.0

    uint hitCount = 0;
    rayQueryEXT query;
    // Opaque query to stop at the first geometry hit (the floor plane)
    rayQueryInitializeEXT(query, topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, origin, tMin, direction, tMax);
    
    // Simulate divergent material execution (Mirror vs Diffuse)
    uint materialWorkLoops = 0;
    
    // Invert the coherenceFactor to represent Roughness. 
    // 1.0 Coherence = 0.0 Roughness (Mirror). 
    // 0.0 Coherence = 1.0 Roughness (Diffuse).
    float roughness = 1.0 - pc.coherenceFactor; 

    // Traverse the BVH
    while (rayQueryProceedEXT(query)) {
    }

    if (rayQueryGetIntersectionTypeEXT(query, true) != gl_RayQueryCommittedIntersectionNoneEXT) {
        hitCount++;
        
        vec3 hitPos = origin + direction * rayQueryGetIntersectionTEXT(query, true);
        // Let's assume the ray hit the geometry. 
        // We now execute the material Hit Shader.
        
        // Complex materials like subsurface scattering or multi-layered diffuse 
        // take thousands of math operations. Simple mirrors take almost none.
        
        // We simulate this by forcing divergent math payloads.
        uint materialWorkLoops = 0;
        
        // A coherence factor of 1.0 means 100% of rays do the fast "Mirror" path.
        // A coherence factor of 0.0 means 100% of rays do the slow "Diffuse" path.
        // We evaluate this per thread based on its stable ID against the coherence dial.
        
        // Use a chaotic but stable thread hash to roll dice
        float threadRoll = float(hash(idx + pc.seed) % 1000) / 1000.0;
        
        if (threadRoll <= pc.coherenceFactor) {
            // Highly coherent path (e.g., simple mirror)
            materialWorkLoops = 50 + (idx % 10); 
        } else {
            // Highly incoherent branching path (e.g., complex multi-scatter diffuse)
            // The iteration count itself jitters wildly to maximize warp divergence
            materialWorkLoops = 15000 + (hash(idx) % 10000); 
        }
        
        // Burn cycles representing the BRDF evaluation
        float dummyMath = 1.0;
        for (uint i = 0; i < materialWorkLoops; i++) {
            dummyMath += sin(float(i) * 0.1) * cos(dummyMath);
        }

        atomicAdd(localHits, hitCount + uint(dummyMath * 0.00001));
    } else {
        atomicAdd(localHits, hitCount);
    }
    barrier();

    if (gl_LocalInvocationID.x == 0 && localHits > 0) {
        atomicAdd(results.hits, localHits);
    }
}
