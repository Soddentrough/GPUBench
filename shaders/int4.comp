#version 460
// Requires Vulkan 1.4+
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer Data {
    i8vec4 data[];
} InOutBuffer;

void main() {
    uint index = gl_GlobalInvocationID.x;

    // Use packed i8vec4 for 4x throughput
    // Emulate 4-bit operations (values kept in 0-15 range)
    i8vec4 val1 = InOutBuffer.data[index] & i8vec4(0x0F);
    i8vec4 val2 = i8vec4(1, 2, 3, 4);
    i8vec4 val3 = i8vec4(5, 6, 7, 8);
    i8vec4 val4 = i8vec4(9, 10, 11, 12);
    i8vec4 val5 = i8vec4(13, 14, 15, 1);
    i8vec4 val6 = i8vec4(2, 3, 4, 5);
    i8vec4 val7 = i8vec4(6, 7, 8, 9);
    i8vec4 val8 = i8vec4(10, 11, 12, 13);
    i8vec4 val9 = i8vec4(14, 15, 1, 2);
    i8vec4 val10 = i8vec4(3, 4, 5, 6);
    i8vec4 val11 = i8vec4(7, 8, 9, 10);
    i8vec4 val12 = i8vec4(11, 12, 13, 14);
    
    // Each iteration performs 12 i8vec4 multiply-adds = 12 * 4 * 2 = 96 INT4 ops
    // (counting 2 ops per 4-bit value packed in each i8vec4 component)
    for (int i = 0; i < 16384; ++i) {
        val1 = (val1 * i8vec4(3) + val2) & i8vec4(0x0F);
        val2 = (val2 * i8vec4(3) + val3) & i8vec4(0x0F);
        val3 = (val3 * i8vec4(3) + val4) & i8vec4(0x0F);
        val4 = (val4 * i8vec4(3) + val5) & i8vec4(0x0F);
        val5 = (val5 * i8vec4(3) + val6) & i8vec4(0x0F);
        val6 = (val6 * i8vec4(3) + val7) & i8vec4(0x0F);
        val7 = (val7 * i8vec4(3) + val8) & i8vec4(0x0F);
        val8 = (val8 * i8vec4(3) + val9) & i8vec4(0x0F);
        val9 = (val9 * i8vec4(3) + val10) & i8vec4(0x0F);
        val10 = (val10 * i8vec4(3) + val11) & i8vec4(0x0F);
        val11 = (val11 * i8vec4(3) + val12) & i8vec4(0x0F);
        val12 = (val12 * i8vec4(3) + val1) & i8vec4(0x0F);
    }
    
    InOutBuffer.data[index] = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8 + val9 + val10 + val11 + val12;
}
