#version 460
// Requires Vulkan 1.4+
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer Data {
    f16vec2 data[];
} InOutBuffer;

void main() {
    uint index = gl_GlobalInvocationID.x;

    // Work with multiple packed accumulators to avoid dependency chains
    // Using f16vec2 for 2x throughput on RDNA2
    f16vec2 val1 = InOutBuffer.data[index];
    f16vec2 val2 = f16vec2(0.1, 0.2);
    f16vec2 val3 = f16vec2(0.3, 0.4);
    f16vec2 val4 = f16vec2(0.5, 0.6);
    f16vec2 val5 = f16vec2(0.7, 0.8);
    f16vec2 val6 = f16vec2(0.9, 1.0);
    f16vec2 val7 = f16vec2(1.1, 1.2);
    f16vec2 val8 = f16vec2(1.3, 1.4);
    
    // Each iteration performs 8 f16vec2 FMAs = 8 * 2 * 2 = 32 FP16 ops
    for (int i = 0; i < 16384; ++i) {
        val1 = fma(val1, f16vec2(1.0001), val2);
        val2 = fma(val2, f16vec2(1.0001), val3);
        val3 = fma(val3, f16vec2(1.0001), val4);
        val4 = fma(val4, f16vec2(1.0001), val5);
        val5 = fma(val5, f16vec2(1.0001), val6);
        val6 = fma(val6, f16vec2(1.0001), val7);
        val7 = fma(val7, f16vec2(1.0001), val8);
        val8 = fma(val8, f16vec2(1.0001), val1);
    }
    
    // Prevent optimization away
    InOutBuffer.data[index] = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;
}
